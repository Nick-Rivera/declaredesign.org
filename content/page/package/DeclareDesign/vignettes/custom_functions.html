---
title: "Custom functions and DeclareDesign"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Custom functions and DeclareDesign}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



<p>Because all inputs to <code>declare_design()</code> are functions, it’s easy for you to provide custom functions instead of using our defaults.</p>
<div id="custom-population" class="section level1">
<h1>Custom Population</h1>
<p>You can use a custom function to generate your population entirely on your own, too:</p>
<pre class="r"><code>my_population_function &lt;- function(N) {
  data.frame(u = rnorm(N))
}

my_population_custom &lt;- declare_population(
  handler = my_population_function, N = 100)

pop_custom &lt;- my_population_custom()

head(pop_custom)</code></pre>
<table>
<thead>
<tr class="header">
<th align="right">u</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">-0.35</td>
</tr>
<tr class="even">
<td align="right">0.61</td>
</tr>
<tr class="odd">
<td align="right">0.74</td>
</tr>
<tr class="even">
<td align="right">0.48</td>
</tr>
<tr class="odd">
<td align="right">0.33</td>
</tr>
<tr class="even">
<td align="right">-1.78</td>
</tr>
</tbody>
</table>
</div>
<div id="custom-potential-outcomes" class="section level1">
<h1>Custom Potential Outcomes</h1>
<pre class="r"><code>my_potential_outcomes_function &lt;-
  function(data) {
    data$Y_Z_0 &lt;- with(data, u)
    data$Y_Z_1 &lt;- with(data, 0.25 + u)
    data
  }
my_potential_outcomes_custom &lt;- declare_potential_outcomes(
  handler = my_potential_outcomes_function
)

pop_pos_custom &lt;- my_potential_outcomes_custom(pop_custom)

head(pop_pos_custom[, c(&quot;u&quot;, &quot;Y_Z_0&quot;, &quot;Y_Z_1&quot;)])</code></pre>
<table>
<thead>
<tr class="header">
<th align="right">u</th>
<th align="right">Y_Z_0</th>
<th align="right">Y_Z_1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">-0.35</td>
<td align="right">-0.35</td>
<td align="right">-0.10</td>
</tr>
<tr class="even">
<td align="right">0.61</td>
<td align="right">0.61</td>
<td align="right">0.86</td>
</tr>
<tr class="odd">
<td align="right">0.74</td>
<td align="right">0.74</td>
<td align="right">0.99</td>
</tr>
<tr class="even">
<td align="right">0.48</td>
<td align="right">0.48</td>
<td align="right">0.73</td>
</tr>
<tr class="odd">
<td align="right">0.33</td>
<td align="right">0.33</td>
<td align="right">0.58</td>
</tr>
<tr class="even">
<td align="right">-1.78</td>
<td align="right">-1.78</td>
<td align="right">-1.53</td>
</tr>
</tbody>
</table>
</div>
<div id="custom-sampling" class="section level1">
<h1>Custom Sampling</h1>
<p>Again, you can still use a custom sampling function easily. In this case, the requirement is simply that the function takes population data and returns sampled data. You can also include inclusion weights if you wish in the function (as the default function does).</p>
<pre class="r"><code>my_sampling_function &lt;- function(data) {
     data$S &lt;- rbinom(n = nrow(data),
            size = 1,
            prob = 0.1)
     data[data$S == 1, ]
}

my_sampling_custom &lt;- declare_sampling(
  handler = my_sampling_function)

smp_custom &lt;- my_sampling_custom(pop_pos)

nrow(smp_custom)</code></pre>
<p>107</p>
</div>
<div id="custom-assignment" class="section level1">
<h1>Custom Assignment</h1>
<pre class="r"><code>my_assignment_function &lt;- function(data) {
  data$Z &lt;- rbinom(n = nrow(data),
         size = 1,
         prob = 0.5)
  data
}
my_assignment_custom &lt;- declare_assignment(
  handler = my_assignment_function)

table(my_assignment_custom(pop_pos)$Z)</code></pre>
<table>
<thead>
<tr class="header">
<th align="right">0</th>
<th align="right">1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">504</td>
<td align="right">496</td>
</tr>
</tbody>
</table>
</div>
<div id="custom-estimand" class="section level1">
<h1>Custom Estimand</h1>
<p>Handlers can also make use of labels, if it’s declared as an argument to the custom handler function.</p>
<pre class="r"><code>my_estimand_function &lt;- function(data, label) {
    data.frame(
      estimand_label=label,
      estimand=with(data, median(Y_Z_1 - Y_Z_0))
    )
}
my_estimand_custom &lt;- declare_estimand(
  handler = my_estimand_function, label = &quot;medianTE&quot;)

my_estimand_custom(pop_pos)</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">estimand_label</th>
<th align="right">estimand</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">medianTE</td>
<td align="right">0.82</td>
</tr>
</tbody>
</table>
</div>
<div id="custom-estimator" class="section level1">
<h1>Custom Estimator</h1>
<p>Custom estimators are slightly different - the default handler itself calls another function, either a model or estimator function, and handles the necessary bookkeeping to align estimators and estimands to later calculate diagnostics.</p>
<pre class="r"><code>my_estimator_function &lt;- function(formula, data){
  data.frame(est = with(data, mean(Y)))
}

my_estimator_custom &lt;- 
  declare_estimator(Y ~ Z, 
                    estimator_function = my_estimator_function, 
                    estimand = my_estimand)

my_estimator_custom(smp)</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">estimator_label</th>
<th align="right">est</th>
<th align="left">estimand_label</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">my_estimator</td>
<td align="right">0.09</td>
<td align="left">ATE</td>
</tr>
</tbody>
</table>
</div>

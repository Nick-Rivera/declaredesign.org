---
title: "Pre-analysis plans with DeclareDesign"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{PAP}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

See blog post at BITSS

# In R

```{r, eval = FALSE}
library(DeclareDesign)

sample_size    <- 100
effect_size    <- 0.5
number_treated <- 50

two_arm_design <-
  
  # M: Model
  declare_population(N = sample_size, noise = rnorm(N)) +
  declare_potential_outcomes(Y ~ effect_size * Z + noise) +
  
  # I: Inquiry
  declare_estimand(ATE = mean(Y_Z_1 - Y_Z_0)) +
  
  # D: Data Strategy
  declare_assignment(m = number_treated) +
  declare_reveal(Y, Z) +
  
  # A: Answer Strategy
  declare_estimator(Y ~ Z, model = lm_robust, estimand = "ATE")
```

You can find an RMarkdown document implementing our suggested additions to 
pre-analysis plans [here](link).

# In Stata

```{eval = FALSE}
program two_arm_design, rclass
  
  syntax [, sample_size(integer 100) effect_size(real .5) number_treated(integer 50)]
    
  drop _all
  
  * // Model
  
  * Population
  
  set obs `sample_size'
  
  gen noise = rnormal(0, 1)
  
  * Potential outcomes
  
  gen Y_Z_0 = noise
  gen Y_Z_1 = noise + `effect_size'
  
  * // Inquiry 

  return scalar estimand = `effect_size'
  
  * // Data strategy
  
  * Assignment strategy
  
  complete_ra Z, m(`number_treated')
  
  * Reveal outcomes
  
  gen     Y = Y_Z_0 
  replace Y = Y_Z_1 if Z == 1
  
  * // Answer strategy
  
  reg Y Z, vce(hc2)
  
  matrix b = e(b)
    
  return scalar estimate = b[1, 1]
  
  return scalar p_value = 2 * ttail(e(df_r), abs(_b[Z]/_se[Z]))

end
```

You can find a Stata `dyndoc` format document implementing our suggested additions to 
pre-analysis plans [here](link).

# In Python

```{python, eval = FALSE}
def draw_data(sample_size = 100, effect_size = 0.5, number_treated = 50):  
    # Model
    
    # Population
    pop = pd.DataFrame({
      'noise' : sp.stats.norm(loc = 0, scale = 1).rvs(sample_size)})

    # Potential outcomes
    pop['Y_Z_0'] = pop['noise']
    pop['Y_Z_1'] = pop['noise'] + effect_size
     
    # Data Strategy
    
    # Assignment strategy
    pop['Z'] = np.random.choice(np.concatenate(([1] * 50, [0] * 50)), sample_size, replace = False)
     
    # Reveal outcomes
    pop['Y'] = pop['Y_Z_0'] * (1 - pop['Z']) + pop['Y_Z_1'] * pop['Z']
    
    return pop;


def fit_model(data):
    # Answer strategy
    model_fit = smf.ols('Y ~ Z', data = data).fit()

    fit = model_fit.get_robustcov_results(cov_type='HC2')
    
    return fit;
```

You can find a reproducible Python `stitch` document implementing our suggested additions to 
pre-analysis plans [here](link).

# In Excel 

<img width="45%" src="pap/figures/two_arm_design_excel_data.png"/>
<img width="45%" src="pap/figures/two_arm_design_excel_estimates.png"/>

You can find a Excel document that declares the key features of the research design
above using cell formulae, pivot tables, and analytical formulae for estimation 
[here](link). 
